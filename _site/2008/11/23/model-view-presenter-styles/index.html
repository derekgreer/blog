<!DOCTYPE html>
<html lang="en-us">

<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <link rel="stylesheet" href="/assets/css/normalize.css"/>
  <link rel="stylesheet" href="/assets/css/bulma.css"/>
  <link rel="stylesheet" href="/assets/css/highlight.css"/>
  <link rel="stylesheet" href="/assets/css/custom.css"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto" rel="stylesheet">

  <!-- Icons -->
  <link rel="shortcut icon" href="/assets/images/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <title>
    
      Model View Presenter Styles &middot; Aspiring Craftsman
    
  </title>

</head>


<body>

<section class="hero is-dark">
  <div class="hero-body">
    <div class="container">
      <h1 class="title">Aspiring Craftsman</h1><div>pursuing well-crafted software</div>
<!--
          <span class="typewrite" data-period="2000" data-type='[ "pursuing well-crafted software"]'>
            <span class="wrap"></span>
          </span>
-->
      <!--
      <h4 class="subtitle" id="quote">
      </h4>
      -->
    </div>
  </div>
</section>

<div class="main-container">
  <div class="tile is-ancestor is-vertical">


    <nav class="nav has-shadow">

      <div class="nav-left">

        <a href="/" class="nav-item">
          <span class="icon">
            <i class="fa fa-home" aria-hidden="true" title="Homepage"></i>
          </span>
        </a>

        <a href="https://github.com/" class="nav-item">
          <span class="icon">
            <i class="fa fa-github" aria-hidden="true" title="Github"></i>
          </span>
        </a>

        <div class="nav-item" id="searchFieldNav">
          <div class="field has-addons">
            <p class="control">
              <input class="input is-small" type="text" placeholder="Find an article" id="search-text">
            </p>
            <p class="control">
              <a class="button is-dark is-small" onclick="searchHandler();">
                Search
              </a>
            </p>
          </div>
        </div>

      </div>

      <div class="nav-right nav-menu" id='nav-menu'>
        <a href="/archive" class="nav-item">Archive</a>
        <a href="/tags" class="nav-item">Tags</a>
      </div>

      <span class="nav-toggle" id="nav-toggle">
          <span></span>
          <span></span>
          <span></span>
    </nav>

    <div class="tile is-parent">
      <div class="tile is-8 is-child main">

        <div class="box">
    <h1 class="post-title">Model View Presenter Styles</h1>
    <span class="post-meta">23 November, 2008. It was a Sunday. <a style="color:grey" href="#disqus_thread"></a></span><hr/>

    <span class="post-text"><h2 id="introduction">Introduction</h2>

<p>The <noindex></noindex> Model-View-Presenter pattern is an interactive application architecture pattern used to separate the concerns of an application’s data, presentation, and user input into specialized components. The article <a href="/2007/08/interactive-application-architecture.html">Interactive Application Architecture Patterns</a> includes an introduction to the MVP pattern along with discussion of its history and pattern variations. In addition to the variations discussed therein, there also exists variation in how the pattern may be implemented. This article presents three styles for implementing the Model-View-Presenter pattern.</p>

<h2 id="the-encapsulated-presenter-style">The Encapsulated Presenter Style</h2>

<p>The first of the styles considered here is what might be called the Encapsulated Presenter style. Following this style, the Presenter exists as an implementation detail of the View. The Presenter responds to event notifications from the Model, but is known only to the View to which it is assigned and consequently is only accessed directly by the View.</p>

<p><a href="http://www.aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedPresenter.png"><img class="aligncenter size-full wp-image-70" title="EncapsulatedPresenter" src="http://www.aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedPresenter.png" alt="" width="467" height="351" srcset="http://aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedPresenter.png 467w, http://aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedPresenter-300x225.png 300w" sizes="(max-width: 467px) 100vw, 467px" /></a></p>

<p>Other components within the system requiring view-related data and/or behavior encapsulated within the Presenter will request access through a reference to the View. This results in consistent access to the encapsulated data and behavior, regardless of whether the access is triggered through the user interface or by other components within the system. One practical benefit gained through this approach is the ability to change the particular pattern used to segment presentation logic without affecting other components within the system. For instance, an application initially designed to use the Supervising Controller or Passive View variations of the MVP pattern may later be refactored to encapsulate both data and behavior using the Presentation Model pattern.</p>

<p>The following example demonstrates the Encapsulated Presenter style:</p>

<pre class="brush:csharp">public interface IView
    {
        string Text { get; set; }

        void Show();
    }

    public class View : IView
    {
        Presenter presenter;

        public View() : this(new Presenter())
        {
        }

        public View(Presenter presenter)
        {
            this.presenter = presenter;
            presenter.View = this;
        }

        #region IView Members

        public string Text { get; set; }

        public void Show()
        {
            presenter.OnShow();

            Console.WriteLine("Current Time: " + Text);
        }

        #endregion

        protected void Button_Click(object sender, EventArgs e)
        {
            presenter.OnButtonClick();
        }
    }

    public class Presenter
    {
        IModel model;

        public Presenter() : this(new Model())
        {
        }

        public Presenter(IModel model)
        {
            this.model = model;
            model.TextChanged += new EventHandler(model_TextChanged);
        }

        public IView View { get; set; }

        void model_TextChanged(object sender, EventArgs e)
        {
            View.Text = model.Text;
        }

        internal void OnButtonClick()
        {
            model.Text = "Button Clicked";
        }

        internal void OnShow()
        {
            // Update view when shown
            View.Text = model.Text;
        }
    }

    public interface IModel
    {
        string Text { get; set; }
        event EventHandler TextChanged;
    }

    public class Model : IModel
    {
        string text;

        public event EventHandler TextChanged = delegate { };

        public string Text
        {
            get { return text ?? (text = DateTime.Now.ToString()); }

            set
            {
                text = value;
                TextChanged(this, EventArgs.Empty);
            }
        }
    }
</pre>

<p>In this example, a View provides constructors for being instantiated with either a default or provided instance of the Presenter. The View then sets its private Presenter instance used later for delegation and sets the Presenter’s View property to itself. The View also contains a Button_Click() event handler representing the initial interceptor for a button control. When invoked, this handler delegates control to the Presenter.OnButtonClick() method.</p>

<p>The Presenter likewise provides constructors for being instantiated with either a default or provided instance of the Model and registers to receive event notifications when the Model changes. When notified, the Presenter updates the Text property of the View.</p>

<p>The following is a test for the presentation logic contained within the Presenter:</p>

<pre class="brush:csharp">[TestClass]
    public class ViewTest
    {
        [TestMethod]
        public void PresenterShouldUpdateViewOnModelChange()
        {
            var model = new Model {Text = "Initial value"};
            var view = new StubView();
            var presenter = new Presenter(model);
            presenter.View = view;
            model.Text = "Changed value";
            Assert.AreEqual(view.Text, "Changed value");
        }
    }

    class StubView : IView
    {
        public string Text { get; set; }

        public void Show()
        {
        }
    }
</pre>

<p>The following code snippet demonstrates how a View might be accessed using the Encapsulated Presenter style:</p>

<pre class="brush:csharp">class Program
    {
        static void Main(string[] args)
        {
            // Show the view
            var view = new View();
            view.Show();

            // Retrieve the view state
            string text = view.Text;

            Console.WriteLine("View text: " + text);
            Console.ReadKey(true);
        }
    }
</pre>

<h2 id="the-encapsulated-view-style">The Encapsulated View Style</h2>

<p>The next style considered will be referred to here as the Encapsulated View style. Following this style, the Presenter serves as an interface to view-related data and behavior accessed by other components within the application. In addition to decoupling the presentation logic from the View, this assigns a form of Page Controller responsibility to the Presenter. As with Page Controller, the Presenter in this style provides input control for views when accessed by other components.</p>

<p><a href="http://www.aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedView.png"><img class="aligncenter size-full wp-image-71" title="EncapsulatedView" src="http://www.aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedView.png" alt="" width="476" height="350" srcset="http://aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedView.png 476w, http://aspiringcraftsman.com/wp-content/uploads/2010/01/EncapsulatedView-300x220.png 300w" sizes="(max-width: 476px) 100vw, 476px" /></a></p>

<p>While the View continues to delegate user input requests to the Presenter, other components within the system interact with view-related data and/or behavior through a reference to the Presenter. One of the benefits of this approach is that it eliminates the need to expose delegating properties or methods on the View which are not otherwise required by the user interface. For example, given a View which presents a selection dialog of mailing addresses associated with a specific customer, this approach would allow other components to call a method directly on the Presenter to display the selection for a given customer number. By allowing access to the Presenter directly, the View interface is free from the need of exposing any properties or methods not directly concerned with the visual display of the application.</p>

<p>The following example demonstrates the Encapsulated View style using an explicit delegation approach:</p>

<pre class="brush:csharp">public interface IView
    {
        IPresenter Presenter { get; set; }
        string Text { get; set; }
        void Show();
    }

    public class View : IView
    {
        public View()
        {
        }

        public IPresenter Presenter { get; set; }
        public string Text { get; set; }

        public void Show()
        {
            Console.WriteLine("Current Time: " + Text);
        }

        protected void Button_Click(object sender, EventArgs e)
        {
            Presenter.OnButtonClick();
        }
    }

    public interface IPresenter
    {
        string Text { get; set; }
        void ShowView();
        void OnButtonClick();
    }

    public partial class Presenter : IPresenter
    {
        IModel model;
        IView view;

        public Presenter() : this(new View(), new Model())
        {
        }

        public Presenter(IView view) : this(view, new Model())
        {
        }

        public Presenter(IView view, IModel model)
        {
            this.view = view;
            this.model = model;
            view.Presenter = this;
            model.TextChanged += new EventHandler(model_TextChanged);
        }

        public string Text
        {
            get { return view.Text; }

            set { view.Text = value; }
        }

        public void OnButtonClick()
        {
            model.Text = "Button Clicked";
        }

        public void ShowView()
        {
            // Update view when shown
            view.Text = model.Text;
            view.Show();
        }

        void model_TextChanged(object sender, EventArgs e)
        {
            view.Text = model.Text;
        }
    }

    public interface IModel
    {
        string Text { get; set; }
        event EventHandler TextChanged;
    }

    public class Model : IModel
    {
        string text;
        public event EventHandler TextChanged = delegate { };

        public string Text
        {
            get { return text ?? (text = DateTime.Now.ToString()); }

            set
            {
                text = value;
                TextChanged(this, EventArgs.Empty);
            }
        }
    }
</pre>

<p>In this example, a Presenter provides constructors for being instantiated with default or provided instances of the View and Model. The Presenter sets its private View and Model instances, sets the View’s Presenter property to itself, and then registers to receive event notifications when the Model changes. When notified, the Presenter updates the Text property of the View.</p>

<p>As with the previous example, the View contains a Button_Click() event handler representing the initial interceptor for a button control. When invoked, it delegates control to the Presenter.OnButtonClick() method.</p>

<p>The following is a test for the presentation logic contained within the Presenter:</p>

<pre class="brush:csharp">[TestClass]
    public class ViewTest
    {
        [TestMethod]
        public void PresenterShouldUpdateViewOnModelChange()
        {
            var model = new Model {Text = "Initial value"};
            var view = new StubView();
            var presenter = new Presenter(view, model);
            model.Text = "Changed value";
            Assert.AreEqual(view.Text, "Changed value");
        }
    }

    class StubView : IView
    {
        public IPresenter Presenter { get; set; }
        public string Text { get; set; }

        public void Show()
        {
        }
    }
</pre>

<p>The following code snippet demonstrates how the View might be displayed using the Encapsulated View style:</p>

<pre class="brush:csharp">public class Program
    {
        public static void Main(string[] args)
        {
            // Show the view
            var presenter = new Presenter();
            presenter.ShowView();

            // Retrieve the view state
            string text = presenter.Text;
            Console.WriteLine("View text: " + text);
            Console.ReadKey(true);
        }
    }
</pre>

<p>While this approach eliminates the need to expose delegating methods on the View (often necessary with the Encapsulated Presenter style), it can result in an inverse need to provide wrapper methods on the Presenter for accessing view state. This can be observed in the above example with the Presenter’s Text property. Another approach taken is to provide direct access to the View as a public property of the Presenter. This, however, constitutes a Law of Demeter violation and as such is considered by some to be a poor programming practice.</p>

<h2 id="the-observing-presenter-style">The Observing Presenter Style</h2>

<p>The final style considered here will be referred to as the Observing Presenter style. Following this style, the Presenter is notified of pertinent activity within the View via the Observer Pattern. The View defines events or delegates to be raised in response to user interaction (or exposes event-raising components), while the Presenter registers for the appropriate events for handling the desired presentation logic.</p>

<p><a href="http://www.aspiringcraftsman.com/wp-content/uploads/2010/01/ObservingPresenter.png"><img class="aligncenter size-full wp-image-72" title="ObservingPresenter" src="http://www.aspiringcraftsman.com/wp-content/uploads/2010/01/ObservingPresenter.png" alt="" width="372" height="688" srcset="http://aspiringcraftsman.com/wp-content/uploads/2010/01/ObservingPresenter.png 372w, http://aspiringcraftsman.com/wp-content/uploads/2010/01/ObservingPresenter-162x300.png 162w" sizes="(max-width: 372px) 100vw, 372px" /></a></p>

<p>This style may be used alongside both the Encapsulated Presenter or Encapsulated View styles. When following the Encapsulated Presenter style, the end user and external components interact directly with the View which raises events handled by the Presenter. When following the Encapsulated View style, user interaction with the View raises events handled by the Presenter, while other components interact directly with the Presenter.</p>

<p>The benefit of the Observing Presenter style is that it completely decouples knowledge of the Presenter from the View making the View less susceptible to changes within the Presenter.</p>

<p>The following example demonstrates the Observing Presenter style with the View encapsulated by the Presenter:</p>

<pre class="brush:csharp">public interface IView
    {
        string Text { get; set; }
        event EventHandler ButtonClick;
        void Show();
    }

    public class View : IView
    {
        public View()
        {
        }

        public event EventHandler ButtonClick;
        public string Text { get; set; }

        public void Show()
        {
            Console.WriteLine("Current Time: " + Text);
        }
    }

    public interface IPresenter
    {
        string Text { get; set; }
        void ShowView();
    }

    public partial class Presenter : IPresenter
    {
        IModel model;
        IView view;

        public Presenter() : this(new View(), new Model())
        {
        }

        public Presenter(IView view) : this(view, new Model())
        {
        }

        public Presenter(IView view, IModel model)
        {
            this.view = view;
            this.model = model;
            InitializeEvents();
        }

        public string Text
        {
            get { return view.Text; }
            set { view.Text = value; }
        }

        public void ShowView()
        {
            // Update view when shown
            view.Text = model.Text;
            view.Show();
        }

        void InitializeEvents()
        {
            model.TextChanged += new EventHandler(model_TextChanged);
            view.ButtonClick += new EventHandler(view_ButtonClick);
        }

        void view_ButtonClick(object sender, EventArgs e)
        {
            OnButtonClick();
        }

        void model_TextChanged(object sender, EventArgs e)
        {
            view.Text = model.Text;
        }

        protected virtual void OnButtonClick()
        {
            model.Text = "Button Clicked";
        }
    }

    public interface IModel
    {
        string Text { get; set; }
        event EventHandler TextChanged;
    }

    public class Model : IModel
    {
        string text;
        public event EventHandler TextChanged = delegate { };

        public string Text
        {
            get { return text ?? (text = DateTime.Now.ToString()); }

            set
            {
                text = value;

                TextChanged(this, EventArgs.Empty);
            }
        }
    }
</pre>

<p>As with the first Encapsulated View example, this example contains a Presenter which provides constructors for being instantiated with default or provided instances of the View and Model. The Presenter sets its private View and Model instances, but this time registers to receive event notifications from both the Model and the View. When notified of changes within the Model, the Presenter updates the Text property of the View. When notified of user interaction on the View, the Model is updated.</p>

<p>The following is a test for the presentation logic contained within the Presenter:</p>

<pre class="brush:csharp">[TestClass]
    public class ViewTest
    {
        [TestMethod]
        public void PresenterShouldUpdateViewOnModelChange()
        {
            var model = new Model {Text = "Initial value"};
            var view = new StubView();
            var presenter = new Presenter(view, model);
            model.Text = "Changed value";
            Assert.AreEqual(view.Text, "Changed value");
        }
    }

    class StubView : IView
    {
        public string Text { get; set; }
        public event EventHandler ButtonClick = delegate { };

        public void Show()
        {
        }

        public void OnButtonClick()
        {
            ButtonClick(this, EventArgs.Empty);
        }
    }
</pre>

<p>The same code demonstrating how the View might be displayed using the Encapsulated View style applies equally for this example:</p>

<pre class="brush:csharp">public class Program

  {

   public static void Main(string[] args)

      {

   // Show the view

          IPresenter presenter = new Presenter();

          presenter.ShowView();

   // Retrieve the view state

   string text = presenter.Text;

          Console.WriteLine("View text: " + text);

          Console.ReadKey(true);

      }

  }
</pre>

<p>While use of the Observer Pattern further decouples the Presenter from the View, this can introduce some added complexity, particularly with respect to testing the behavior contained within the Presenter. Since event handlers are generally marked either private or protected, they are not readily accessible within a unit test. In general, testing the internals of a component is unnecessary since all behavior is normally exercised through the component’s public interface. Unfortunately, this is often not the case with delegates. A thorough discussion of testing non-public methods and event handlers is beyond the intended scope of this article. However, one approach that can be used for this type of testing is to provision delegate invocation through a testing stub.</p>

<p>In the following example, a Presenter contains an event handler which expects a custom EventArgs generic type containing a Data property of type string:</p>

<pre class="brush:csharp">public class Presenter : IPresenter
    {
        // ...

        void view_ButtonClick(object sender, DataEventArgs&lt;string&gt; e)
        {
            OnButtonClick(e.Data);
        }

        protected virtual void OnButtonClick(string value)
        {
            model.Text = value;
        }

        // ...
    }
</pre>

<p>By supplying a testing stub with a method for raising the event with an expected value, the resulting state can be tested without direct access to the Presenter method:</p>

<pre class="brush:csharp">[TestClass]
    public class ViewTest
    {
        [TestMethod]
        public void OnButtonClickSetsExpectedValue()
        {
            var view = new StubView();
            var presenter = new Presenter(view);
            view.OnButtonClick("Expected Value");
            Assert.AreEqual(view.Text, "Expected Value");
        }
    }

    public class StubView : IView
    {
        public string Text { get; set; }

        public void Show()
        {
        }

        public event EventHandler&lt;string&gt; ButtonClick = delegate { };

        public void OnButtonClick(string value)
        {
            ButtonClick(this, new DataEventArgs&lt;string&gt;(value));
        }
    }
</pre>

<h2 id="conclusion">Conclusion</h2>

<p>While there are several approaches to how one may implement the Model-View-Presenter pattern, the chosen approach is to some degree a matter of personal taste. That being said, each approach does have its pros and cons. When choosing one style over another, consider the impact the chosen approach will have on the style and level of testing to be performed along with the encapsulation requirements of the application.</p>
</span>
</div>

<!--<div class="box">-->
    <!-- google ads code box -->
<!--</div>-->




  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'aspiringcraftsman'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>

      <div class="tile is-4 is-child">
        <div class="tile is-parent is-vertical sidebar">

          <div class="tile is-child widget">

            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Recent Posts
                </p>
              </header>
              <div class="card-content">
                <div class="content nice-text">
                  <ul>
                  
                  <li><a href="/2017/05/25/hello-react-a-beginners-setup-tutorial/">
                    Hello, React! - A Beginner's Setup Tutorial
                  </a></li>
                  
                  <li><a href="/2016/08/30/exploring-typescript/">
                    Exploring TypeScript
                  </a></li>
                  
                  <li><a href="/2016/08/22/git-on-windows-whence-cometh-configuration/">
                    Git on Windows: Whence Cometh Configuration
                  </a></li>
                  
                  <li><a href="/2016/02/28/separation-of-concerns-application-builds-continuous-integration/">
                    Separation of Concerns: Application Builds & Continuous Integration
                  </a></li>
                  
                  <li><a href="/2015/11/01/survey-of-entity-framework-unit-of-work-patterns/">
                    Survey of Entity Framework Unit of Work Patterns
                  </a></li>
                  
                  <li><a href="/2015/03/08/introducing-nunit-specifications/">
                    Introducing NUnit.Specifications
                  </a></li>
                  
                  <li><a href="/2014/03/05/being-agile/">
                    Being Agile
                  </a></li>
                  
                  <li><a href="/2013/11/17/expected-objects-custom-comparisons/">
                    Expected Objects Custom Comparisons
                  </a></li>
                  
                  <li><a href="/2013/04/17/rabbitbus-an-example/">
                    RabbitBus: An Example
                  </a></li>
                  
                  <li><a href="/2013/01/27/adventures-in-debugging-the-nhibernate-dont-flush-the-session-error/">
                    Adventures in Debugging: The NHibernate 'don't flush the Session' Error
                  </a></li>
                  
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="tile is-child widget">
            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Recommended Websites
                </p>
              </header>
              <div class="card-content">
                <div class="content nice-text">
                  <ul>
                    <li>
                      <a href="https://lostechies.com">Los Techies</a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

        </div>

      </div>

    </div>

  </div>
</div>

<footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <p>
      <a class="icon" href="https://github.com/derekgreer">
          <i class="fa fa-github" title="Github"></i>
        </a>
        <a class="icon" href="https://in.linkedin.com/in/derekgreer">
          <i class="fa fa-linkedin" title="Linkedin"></i>
        </a>
        <a class="icon" href="mailto:dbgreer@gmail.com">
          <i class="fa fa-envelope" title="Email"></i>
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- js -->
<script src="/assets/js/custom.js"></script>
<script src="/assets/js/typewriter.js"></script>
</body>
</html>
