<!DOCTYPE html>
<html lang="en-us">

<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <link rel="stylesheet" href="/assets/css/normalize.css"/>
  <link rel="stylesheet" href="/assets/css/bulma.css"/>
  <link rel="stylesheet" href="/assets/css/highlight.css"/>
  <link rel="stylesheet" href="/assets/css/custom.css"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto" rel="stylesheet">

  <!-- Icons -->
  <link rel="shortcut icon" href="/assets/images/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/AspiringCraftsman">

  <title>
    
      Double Dispatch is a Code Smell &middot; Aspiring Craftsman
    
  </title>

</head>


<body>

<section class="hero is-dark">
  <div class="hero-body">
    <div class="container">
      <h1 class="title">Aspiring Craftsman</h1><div>pursuing well-crafted software</div>
<!--
          <span class="typewrite" data-period="2000" data-type='[ "pursuing well-crafted software"]'>
            <span class="wrap"></span>
          </span>
-->
      <!--
      <h4 class="subtitle" id="quote">
      </h4>
      -->
    </div>
  </div>
</section>

<div class="main-container">
  <div class="tile is-ancestor is-vertical">


    <nav class="nav has-shadow">

      <div class="nav-left">

        <a href="/" class="nav-item">
          <span class="icon">
            <i class="fa fa-home" aria-hidden="true" title="Homepage"></i>
          </span>
        </a>

        <a href="https://github.com/derekgreer" class="nav-item">
          <span class="icon">
            <i class="fa fa-github" aria-hidden="true" title="Github"></i>
          </span>
        </a>

        <div class="nav-item" id="searchFieldNav">
          <div class="field has-addons">
            <p class="control">
              <input class="input is-small" type="text" placeholder="Find an article" id="search-text">
            </p>
            <p class="control">
              <a class="button is-dark is-small" onclick="searchHandler();">
                Search
              </a>
            </p>
          </div>
        </div>

      </div>

      <div class="nav-right nav-menu" id='nav-menu'>
        <a href="/archive" class="nav-item">Archive</a>
        <a href="/tags" class="nav-item">Tags</a>
        <a href="/about" class="nav-item">About</a>
        <a href="http://feeds.feedburner.com/AspiringCraftsman" class="nav-item"><img src="/assets/images/rss.png"/></a>
      </div>

      <span class="nav-toggle" id="nav-toggle">
          <span></span>
          <span></span>
          <span></span>
    </nav>

    <div class="tile is-parent">
      <div class="tile is-8 is-child main">

        <div class="box">
    <h1 class="post-title">Double Dispatch is a Code Smell</h1>
    <span class="post-meta">19 April, 2010. It was a Monday. <a style="color:grey" href="#disqus_thread"></a></span><hr/>

    <span class="post-text"><p>If you’re using <a href="http://en.wikipedia.org/wiki/Double_dispatch">Double <noindex></noindex> Dispatch</a> in your code, this may be a symptom of an underlying design issue which may impact the maintainability of your application. Due to the fact that Double Dispatch is at times confused with a form of the <a href="http://en.wikipedia.org/wiki/Strategy_Pattern">Strategy Pattern</a>, an overview may be in order to elaborate on this assertion further.</p>

<h2 id="what-is-double-dispatch">What is Double Dispatch?</h2>

<p>Technically, Double Dispatch refers to a technique used in the context of a polymorphic method call for mitigating the lack of <a href="http://en.wikipedia.org/wiki/Multimethods">multimethod</a> support in programming languages. More simply, Double Dispatch is used to invoke an overloaded method where the parameters vary among an inheritance hierarchy. To explain fully, let’s start with a review of <a href="http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming">polymorphism</a>.</p>

<h3 id="polymorphism">Polymorphism</h3>

<p>In the following example, a hierarchy of shapes are defined with each of the derived types overloading a base virtual <code class="highlighter-rouge">Draw()</code> method. Next, a console application is used to define a list of each of the shapes and iterate over each shape in the collection calling the <code class="highlighter-rouge">Draw()</code> method of each item in the list:</p>

<pre class="brush:csharp">class Shape
    {
        public virtual void Draw()
        {
            Console.WriteLine("A shape is drawn.");
        }
    }

    class Polygon : Shape
    {
        public override void Draw()
        {
            Console.WriteLine("A polygon is drawn.");
        }
    }

    class Quadrilateral : Polygon
    {
        public override void Draw()
        {
            Console.WriteLine("A quadrilateral is drawn.");
        }
    }

    class Parallelogram : Quadrilateral
    {
        public override void Draw()
        {
            Console.WriteLine("A parallelogram is drawn.");
        }
    }

    class Rectangle : Parallelogram
    {
        public override void Draw()
        {
            Console.WriteLine("A rectangle is drawn.");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var shapes = new List&lt;Shape&gt;
                             {
                                 new Shape(),
                                 new Polygon(),
                                 new Quadrilateral(),
                                 new Parallelogram(),
                                 new Rectangle()
                             };

            foreach (Shape shape in shapes)
            {
                shape.Draw();
            }

            Console.ReadLine();
        }
    }
</pre>

<p>The following lines are printed to the console upon running the application:</p>

<pre>A shape is drawn.
A polygon is drawn.
A quadrilateral is drawn.
A parallelogram is drawn.
A rectangle is drawn.
</pre>

<p>Note that the proper <code class="highlighter-rouge">Draw()</code> method is called for each item in the collection. In most object-oriented languages, this polymorphic behavior is achieved through the use of a <a href="http://en.wikipedia.org/wiki/Virtual_table">virtual table</a> consulted at run-time to derive the proper offset address for an object’s method. This behavior is referred to as “<a href="http://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic Dispatch</a>” or “Single Dispatch”. So, how does this relate to Double Dispatch? To answer this question, let’s next review <a href="http://en.wikipedia.org/wiki/Function_overloading">method overloading</a>.</p>

<h3 id="method-overloading">Method Overloading</h3>

<p>In the following example, our <code class="highlighter-rouge">Shape</code> class is redefined to have two overloaded <code class="highlighter-rouge">Draw</code> methods: one with a parameter of type <code class="highlighter-rouge">Surface</code> and one with a parameter of type <code class="highlighter-rouge">EtchASketch</code>:</p>

<pre class="brush:csharp">class Surface
    {
    }

    class EtchASketch : Surface
    {
    }

    class Shape
    {
        public void Draw(Surface surface)
        {
            Console.WriteLine("A shape is drawn on the surface with ink.");
        }

        public void Draw(EtchASketch etchASketch)
        {
            Console.WriteLine("The knobs are moved in attempt to draw the shape.");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var shape = new Shape();
            shape.Draw(new Surface());
            shape.Draw(new EtchASketch());

            Console.ReadLine();
        }
    }
</pre>

<p>When executed, the following lines are printed to the console:</p>

<pre>A shape is drawn on the surface with ink.
The knobs are moved in attempt to draw the shape.</pre>

<p>Note that the parameter type determines which <code class="highlighter-rouge">Draw()</code> method is invoked.</p>

<p>But what happens if we change the <code class="highlighter-rouge">Main()</code> method to the following?</p>

<pre class="brush:csharp">class Program
    {
        static void Main(string[] args)
        {
            var shape = new Shape();
            Surface surface = new Surface();
            Surface etchASketch = new EtchASketch();

            shape.Draw(surface);
            shape.Draw(etchASketch);

            Console.ReadLine();
        }
    }
</pre>

<p>Executing this produces the following:</p>

<pre>A shape is drawn on the surface with ink.
A shape is drawn on the surface with ink.</pre>

<p>What happened? The issue here is that the method to call was determined statically at compile time based upon the reference type, not at run-time based upon the object type. To resolve this issue, another technique is needed … Polymorphic Static Binding.</p>

<h3 id="polymorphic-static-binding">Polymorphic Static Binding</h3>

<p>Polymorphic static binding is a technique where static method invocations are determined at run-time through the use of polymorphism. This can be demonstrated in our example by adding a new <code class="highlighter-rouge">Draw(Shape shape)</code> method to the <code class="highlighter-rouge">Surface</code> and <code class="highlighter-rouge">EtchASketch</code> types which call <code class="highlighter-rouge">shape.Draw()</code> with a reference to the current object:</p>

<pre class="brush:csharp">class Surface
    {
        public virtual void Draw(Shape shape)
        {
            shape.Draw(this);
        }
    }

    class EtchASketch : Surface
    {
        public override void Draw(Shape shape)
        {
            shape.Draw(this);
        }
    }
</pre>

<p>To invoke the correct <code class="highlighter-rouge">Shape.Draw()</code> method, our console application needs to be modified to call the the method indirectly through a <code class="highlighter-rouge">Surface</code> reference:</p>

<pre class="brush:csharp">class Program
    {
        static void Main(string[] args)
        {
            var shape = new Shape();
            Surface surface = new Surface();
            Surface etchASketch = new EtchASketch();

            surface.Draw(shape);
            etchASketch.Draw(shape);

            Console.ReadLine();
        }
    }
</pre>

<p>Upon executing the application again, the following lines are now printed:</p>

<pre>A shape is drawn on the surface with ink.
The knobs are moved in attempt to draw the shape.</pre>

<p>This example achieves the desired result by effectively wrapping the static-dispatched method invocation (i.e. <code class="highlighter-rouge">Shape.Draw()</code>) within a virtual-dispatch method invocation (i.e. <code class="highlighter-rouge">Surface.Draw()</code> and <code class="highlighter-rouge">EtchASketch.Draw()</code>). This causes the static <code class="highlighter-rouge">Shape.Draw()</code> method invocation to be determined by which virtual <code class="highlighter-rouge">Surface.Draw()</code> method invocation is executed.</p>

<p>Although the above example now contains a method invocation using a reference to the current object as the method parameter (often seen with Double Dispatch), it should be noted that Double Dispatch has yet to be demonstrated. Thus far, only one level of virtual dispatching has been used. To demonstrate Double Dispatch, the techniques from both the polymorphism example and the polymorphic static binding example need to be combined as seen in the next section.</p>

<h3 id="double-dispatch">Double Dispatch</h3>

<p>The following example contains a hierarchy of <code class="highlighter-rouge">Surface</code> types and a hierarchy of <code class="highlighter-rouge">Shape</code> types. Each <code class="highlighter-rouge">Shape</code> type contains an overloaded virtual <code class="highlighter-rouge">Draw()</code> method which contains the logic for how the shape is to be drawn on a particular surface. The example console application uses the polymorphic static binding technique to ensure the proper overload is called for each surface type:</p>

<pre class="brush:csharp">class Surface
    {
        public virtual void Draw(Shape shape)
        {
            shape.Draw(this);
        }
    }

    class EtchASketch : Surface
    {
        public override void Draw(Shape shape)
        {
            shape.Draw(this);
        }
    }

    class Shape
    {
        public virtual void Draw(Surface surface)
        {
            Console.WriteLine("A shape is drawn on the surface with ink.");
        }

        public virtual void Draw(EtchASketch etchASketch)
        {
            Console.WriteLine("The knobs are moved in attempt to draw the shape.");
        }
    }

    class Polygon : Shape
    {
        public override void Draw(Surface surface)
        {
            Console.WriteLine("A polygon is drawn on the surface with ink.");
        }

        public override void Draw(EtchASketch etchASketch)
        {
            Console.WriteLine("The knobs are moved in attempt to draw the polygon.");
        }
    }

    class Quadrilateral : Polygon
    {
        public override void Draw(Surface surface)
        {
            Console.WriteLine("A quadrilateral is drawn on the surface with ink.");
        }

        public override void Draw(EtchASketch etchASketch)
        {
            Console.WriteLine("The knobs are moved in attempt to draw the quadrilateral.");
        }
    }

    class Parallelogram : Quadrilateral
    {
        public override void Draw(Surface surface)
        {
            Console.WriteLine("A parallelogram is drawn on the surface with ink.");
        }

        public override void Draw(EtchASketch etchASketch)
        {
            Console.WriteLine("The knobs are moved in attempt to draw the parallelogram.");
        }
    }

     class Rectangle : Parallelogram
    {
        public override void Draw(Surface surface)
        {
            Console.WriteLine("A rectangle is drawn on the surface with ink.");
        }

        public override void Draw(EtchASketch etchASketch)
        {
            Console.WriteLine("The knobs are moved in attempt to draw the rectangle.");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Surface surface = new Surface();
            Surface etchASketch = new EtchASketch();

            var shapes = new List&lt;Shape&gt;
                             {
                                 new Shape(),
                                 new Polygon(),
                                 new Quadrilateral(),
                                 new Parallelogram(),
                                 new Rectangle()
                             };

            foreach (Shape shape in shapes)
            {
                surface.Draw(shape);
                etchASketch.Draw(shape);
            }

            Console.ReadLine();
        }
    }
</pre>

<p>Executing this example produces the following:</p>

<pre>A shape is drawn on the surface with ink.
The knobs are moved in attempt to draw the shape.
A polygon is drawn on the surface with ink.
The knobs are moved in attempt to draw the polygon.
A quadrilateral is drawn on the surface with ink.
The knobs are moved in attempt to draw the quadrilateral.
A parallelogram is drawn on the surface with ink.
The knobs are moved in attempt to draw the parallelogram.
A rectangle is drawn on the surface with ink.
The knobs are moved in attempt to draw the rectangle.
</pre>

<p>In the above example, virtual dispatch occurs twice for each call to one of the <code class="highlighter-rouge">Surface</code> references: Once when the <code class="highlighter-rouge">Surface.Draw()</code> virtual method is called and again when either calls the <code class="highlighter-rouge">Shape.Draw()</code> overloaded virtual method. Note again that while the second virtual dispatch is based on the type of <code class="highlighter-rouge">Shape</code> instance, the overloaded method called is still determined statically based upon the reference type.</p>

<h2 id="consequences">Consequences</h2>

<p>So, what’s wrong with Double Dispatch? The problem isn’t so much in the technique, but what design choices might be leading to reliance upon the technique. Consider for instance the hierarchy of shape types in our Double Dispatch example. What happens if we want to add a new surface? In this case, each of the shape types will need to be modified to add knowledge of the new Surface type. This violates the <a href="http://en.wikipedia.org/wiki/Open_Closed_Principle">Open/Closed Principle</a>, and in this case in a particularly egregious way (i.e. Its violation is multiplied by the number of shape types we have). Additionally, it violates the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>. Changes to how shapes are drawn on a particular surface are likely to differ from surface to surface, thereby leading our shape objects to change for different reasons.</p>

<p>The presence of Double Dispatch generally means that each type in a hierarchy has special handling code within another hierarchy of types. This approach to representing variant behavior leads to code that is less resilient to future changes as well as being more difficult to extend.</p>

<h2 id="the-matrix-reloaded">The Matrix: Reloaded</h2>

<p>Let’s take another stab at modeling our shape/surface intersection matrix. In the following example, several new concepts have been introduced to facilitate decoupling: line segments, points, and brushes:</p>

<pre class="brush:csharp">interface ISurface
    {
        void Add(LineSegment segment);
    }

    class Paper : ISurface
    {
        readonly IList&lt;LineSegment&gt; _segments = new List&lt;LineSegment&gt;();

        public void Add(LineSegment segment)
        {
            _segments.Add(segment);
        }
    }

    class EtchASketch : ISurface
    {
        readonly IList&lt;LineSegment&gt; _segments = new List&lt;LineSegment&gt;();

        public void Add(LineSegment segment)
        {
            _segments.Add(segment);
        }
    }

    class Point
    {
        public Point(int x, int y)
        {
            X = x;
            Y = y;
        }

        public int X { get; set; }
        public int Y { get; set; }
    }

    class LineSegment
    {
        public LineSegment(Point point1, Point point2)
        {
            Point1 = point1;
            Point2 = point2;
        }

        public Point Point1 { get; set; }
        public Point Point2 { get; set; }
    }

    interface IShape
    {
        IList&lt;LineSegment&gt; GetLineSegments();
    }

    class Polygon : IShape
    {
        public IList&lt;LineSegment&gt; GetLineSegments()
        {
            var segments = new List&lt;LineSegment&gt;();
            segments.Add(new LineSegment(new Point(0, 0), new Point(0, 9)));
            segments.Add(new LineSegment(new Point(0, 9), new Point(3, 6)));
            segments.Add(new LineSegment(new Point(3, 6), new Point(6, 9)));
            segments.Add(new LineSegment(new Point(6, 0), new Point(6, 9)));
            segments.Add(new LineSegment(new Point(6, 0), new Point(3, 3)));
            segments.Add(new LineSegment(new Point(3, 3), new Point(0, 0)));

            return segments;
        }
    }

    class Quadrilateral : IShape
    {
        public IList&lt;LineSegment&gt; GetLineSegments()
        {
            var segments = new List&lt;LineSegment&gt;();
            segments.Add(new LineSegment(new Point(0, 0), new Point(0, 9)));
            segments.Add(new LineSegment(new Point(0, 9), new Point(4, 5)));
            segments.Add(new LineSegment(new Point(4, 0), new Point(0, 4)));
            segments.Add(new LineSegment(new Point(4, 0), new Point(0, 0)));

            return segments;
        }
    }

    class Parallelogram : IShape
    {
        public IList&lt;LineSegment&gt; GetLineSegments()
        {
            var segments = new List&lt;LineSegment&gt;();
            segments.Add(new LineSegment(new Point(0, 4), new Point(0, 9)));
            segments.Add(new LineSegment(new Point(0, 9), new Point(4, 5)));
            segments.Add(new LineSegment(new Point(4, 0), new Point(4, 5)));
            segments.Add(new LineSegment(new Point(4, 0), new Point(0, 4)));

            return segments;
        }
    }

    class Rectangle : IShape
    {
        public IList&lt;LineSegment&gt; GetLineSegments()
        {
            var segments = new List&lt;LineSegment&gt;();
            segments.Add(new LineSegment(new Point(0, 0), new Point(0, 9)));
            segments.Add(new LineSegment(new Point(0, 9), new Point(9, 4)));
            segments.Add(new LineSegment(new Point(4, 0), new Point(9, 4)));
            segments.Add(new LineSegment(new Point(4, 0), new Point(0, 0)));

            return segments;
        }
    }

    class Program
    {
        static readonly IDictionary&lt;Type, IBrush&gt; brushDictionary = new Dictionary&lt;Type, IBrush&gt;();

        static Program()
        {
            brushDictionary.Add(typeof (Paper), new Pencil());
            brushDictionary.Add(typeof (EtchASketch), new EtchASketchKnobs());
        }

        static void Main(string[] args)
        {
            var surfaces = new List&lt;ISurface&gt;
                               {
                                   new Paper(),
                                   new EtchASketch()
                               };

            var shapes = new List&lt;IShape&gt;
                             {
                                 new Polygon(),
                                 new Quadrilateral(),
                                 new Parallelogram(),
                                 new Rectangle()
                             };

            foreach (ISurface surface in surfaces)
                foreach (IShape shape in shapes)
                {
                    Console.WriteLine(string.Format("Drawing a {0} on the {1} ...", shape.GetType().Name,
                                                    surface.GetType().Name));
                    brushDictionary[surface.GetType()].Draw(surface, shape.GetLineSegments());
                    Console.WriteLine(Environment.NewLine);
                }

            Console.ReadLine();
        }
    }

    interface IBrush
    {
        void Draw(ISurface surface, IList&lt;LineSegment&gt; segments);
    }

    class Pencil : IBrush
    {
        public void Draw(ISurface surface, IList&lt;LineSegment&gt; segments)
        {
            foreach (LineSegment segment in segments)
            {
                Console.WriteLine(string.Format("Pencil used to sketch line segment {0},{1} to {2},{3}.",
                                                segment.Point1.X, segment.Point1.Y,
                                                segment.Point2.X, segment.Point2.Y));
            }
        }
    }

    class EtchASketchKnobs : IBrush
    {
        public void Draw(ISurface surface, IList&lt;LineSegment&gt; segments)
        {
            foreach (LineSegment segment in segments)
            {
                Console.WriteLine(string.Format("Knobs used to produce line segment {0},{1} to {2},{3}.",
                                                segment.Point1.X, segment.Point1.Y,
                                                segment.Point2.X, segment.Point2.Y));
            }
        }
    }
</pre>

<p>Executing this example produces the following:</p>

<pre>Drawing a Polygon on the Paper ...
Pencil used to sketch line segment 0,0 to 0,9.
Pencil used to sketch line segment 0,9 to 3,6.
Pencil used to sketch line segment 3,6 to 6,9.
Pencil used to sketch line segment 6,0 to 6,9.
Pencil used to sketch line segment 6,0 to 3,3.
Pencil used to sketch line segment 3,3 to 0,0.

Drawing a Quadrilateral on the Paper ...
Pencil used to sketch line segment 0,0 to 0,9.
Pencil used to sketch line segment 0,9 to 4,5.
Pencil used to sketch line segment 4,0 to 0,4.
Pencil used to sketch line segment 4,0 to 0,0.

Drawing a Parallelogram on the Paper ...
Pencil used to sketch line segment 0,4 to 0,9.
Pencil used to sketch line segment 0,9 to 4,5.
Pencil used to sketch line segment 4,0 to 4,5.
Pencil used to sketch line segment 4,0 to 0,4.

Drawing a Rectangle on the Paper ...
Pencil used to sketch line segment 0,0 to 0,9.
Pencil used to sketch line segment 0,9 to 9,4.
Pencil used to sketch line segment 4,0 to 9,4.
Pencil used to sketch line segment 4,0 to 0,0.

Drawing a Polygon on the EtchASketch ...
Knobs used to produce line segment 0,0 to 0,9.
Knobs used to produce line segment 0,9 to 3,6.
Knobs used to produce line segment 3,6 to 6,9.
Knobs used to produce line segment 6,0 to 6,9.
Knobs used to produce line segment 6,0 to 3,3.
Knobs used to produce line segment 3,3 to 0,0.

Drawing a Quadrilateral on the EtchASketch ...
Knobs used to produce line segment 0,0 to 0,9.
Knobs used to produce line segment 0,9 to 4,5.
Knobs used to produce line segment 4,0 to 0,4.
Knobs used to produce line segment 4,0 to 0,0.

Drawing a Parallelogram on the EtchASketch ...
Knobs used to produce line segment 0,4 to 0,9.
Knobs used to produce line segment 0,9 to 4,5.
Knobs used to produce line segment 4,0 to 4,5.
Knobs used to produce line segment 4,0 to 0,4.

Drawing a Rectangle on the EtchASketch ...
Knobs used to produce line segment 0,0 to 0,9.
Knobs used to produce line segment 0,9 to 9,4.
Knobs used to produce line segment 4,0 to 9,4.
Knobs used to produce line segment 4,0 to 0,0.</pre>

<p>By changing the <code class="highlighter-rouge">Shape</code> objects to be defined in terms of line segments, knowledge is removed from the shape concerning how to draw itself on any particular surface. Additionally, the <code class="highlighter-rouge">Surface</code> type now encapsulates a collection of line segments to simulate the lines being drawn onto the surface. To handle drawing the line segments onto the surfaces, we’ve introduced a <code class="highlighter-rouge">Brush</code> type which “draws” the line segments onto a surface in its own peculiar way. To configure which brushes are to be used with which surface, the console application defines a dictionary matching surfaces to brushes.</p>

<p>In contrast to the Double Dispatch example, none of the existing types need to be modified to add new surfaces, shapes, or brushes.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Since Double Dispatch is a technique for calling virtual overloaded methods based upon parameter types which exist within an inheritance hierarchy, its use may be a symptom that the Open/Closed and/or Single responsibility principles are being violated, or that responsibilities may otherwise be misaligned. This is not to say that every case of Double Dispatch means something is amiss, but only that its use should be a flag to reconsider your design in light of future maintenance needs.</p>
</span>
</div>

<!--<div class="box">-->
    <!-- google ads code box -->
<!--</div>-->




  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'aspiringcraftsman'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>

      <div class="tile is-4 is-child">
        <div class="tile is-parent is-vertical sidebar">

          <div class="tile is-child widget">

            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Recent Posts
                </p>
              </header>
              <div class="card-content">
                <div class="content nice-text">
                  <ul>
                  
                  <li><a href="/2017/05/25/hello-react-a-beginners-setup-tutorial/">
                    Hello, React! - A Beginner's Setup Tutorial
                  </a></li>
                  
                  <li><a href="/2016/08/30/exploring-typescript/">
                    Exploring TypeScript
                  </a></li>
                  
                  <li><a href="/2016/08/22/git-on-windows-whence-cometh-configuration/">
                    Git on Windows: Whence Cometh Configuration
                  </a></li>
                  
                  <li><a href="/2016/02/28/separation-of-concerns-application-builds-continuous-integration/">
                    Separation of Concerns: Application Builds & Continuous Integration
                  </a></li>
                  
                  <li><a href="/2015/11/01/survey-of-entity-framework-unit-of-work-patterns/">
                    Survey of Entity Framework Unit of Work Patterns
                  </a></li>
                  
                  <li><a href="/2015/03/08/introducing-nunit-specifications/">
                    Introducing NUnit.Specifications
                  </a></li>
                  
                  <li><a href="/2014/03/05/being-agile/">
                    Being Agile
                  </a></li>
                  
                  <li><a href="/2013/11/17/expected-objects-custom-comparisons/">
                    Expected Objects Custom Comparisons
                  </a></li>
                  
                  <li><a href="/2013/04/17/rabbitbus-an-example/">
                    RabbitBus: An Example
                  </a></li>
                  
                  <li><a href="/2013/01/27/adventures-in-debugging-the-nhibernate-dont-flush-the-session-error/">
                    Adventures in Debugging: The NHibernate 'don't flush the Session' Error
                  </a></li>
                  
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="tile is-child widget">
            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Recommended Websites
                </p>
              </header>
              <div class="card-content">
                <div class="content nice-text">
                  <ul>
                    <li>
                      <a href="https://lostechies.com">Los Techies</a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

        </div>

      </div>

    </div>

  </div>
</div>

<footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <p>
      <a class="icon" href="https://github.com/derekgreer">
          <i class="fa fa-github" title="Github"></i>
        </a>
        <a class="icon" href="https://in.linkedin.com/in/derekgreer">
          <i class="fa fa-linkedin" title="Linkedin"></i>
        </a>
        <a class="icon" href="mailto:dbgreer@gmail.com">
          <i class="fa fa-envelope" title="Email"></i>
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- js -->
<script src="/assets/js/custom.js"></script>
<script src="/assets/js/typewriter.js"></script>
</body>
</html>
